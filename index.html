<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ÌûàÎùºÍ∞ÄÎÇò ÌäπÌõà</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f16; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    body { user-select:none; -webkit-user-select:none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  // ---------------------------
  // 1) DATA
  // ---------------------------
  const PAIRS = [
    { hira: "„ÅÇ", hangul: "ÏïÑ", romaji: "a" },
    { hira: "„ÅÑ", hangul: "Ïù¥", romaji: "i" },
    { hira: "„ÅÜ", hangul: "Ïö∞", romaji: "u" },
    { hira: "„Åà", hangul: "Ïóê", romaji: "e" },
    { hira: "„Åä", hangul: "Ïò§", romaji: "o" },

    { hira: "„Åã", hangul: "Ïπ¥", romaji: "ka" },
    { hira: "„Åç", hangul: "ÌÇ§", romaji: "ki" },
    { hira: "„Åè", hangul: "Ïø†", romaji: "ku" },
    { hira: "„Åë", hangul: "ÏºÄ", romaji: "ke" },
    { hira: "„Åì", hangul: "ÏΩî", romaji: "ko" },

    { hira: "„Åï", hangul: "ÏÇ¨", romaji: "sa" },
    { hira: "„Åó", hangul: "Ïãú", romaji: "shi" },
    { hira: "„Åô", hangul: "Ïä§", romaji: "su" },
    { hira: "„Åõ", hangul: "ÏÑ∏", romaji: "se" },
    { hira: "„Åù", hangul: "ÏÜå", romaji: "so" },

    { hira: "„Åü", hangul: "ÌÉÄ", romaji: "ta" },
    { hira: "„Å°", hangul: "Ïπò", romaji: "chi" },
    { hira: "„Å§", hangul: "Ï∏†", romaji: "tsu" },
    { hira: "„Å¶", hangul: "ÌÖå", romaji: "te" },
    { hira: "„Å®", hangul: "ÌÜ†", romaji: "to" },

    { hira: "„Å™", hangul: "ÎÇò", romaji: "na" },
    { hira: "„Å´", hangul: "Îãà", romaji: "ni" },
    { hira: "„Å¨", hangul: "ÎàÑ", romaji: "nu" },
    { hira: "„Å≠", hangul: "ÎÑ§", romaji: "ne" },
    { hira: "„ÅÆ", hangul: "ÎÖ∏", romaji: "no" },

    { hira: "„ÅØ", hangul: "Ìïò", romaji: "ha" },
    { hira: "„Å≤", hangul: "Ìûà", romaji: "hi" },
    { hira: "„Åµ", hangul: "ÌõÑ", romaji: "fu" },
    { hira: "„Å∏", hangul: "Ìó§", romaji: "he" },
    { hira: "„Åª", hangul: "Ìò∏", romaji: "ho" },

    { hira: "„Åæ", hangul: "Îßà", romaji: "ma" },
    { hira: "„Åø", hangul: "ÎØ∏", romaji: "mi" },
    { hira: "„ÇÄ", hangul: "Î¨¥", romaji: "mu" },
    { hira: "„ÇÅ", hangul: "Î©î", romaji: "me" },
    { hira: "„ÇÇ", hangul: "Î™®", romaji: "mo" },

    { hira: "„ÇÑ", hangul: "Ïïº", romaji: "ya" },
    { hira: "„ÇÜ", hangul: "Ïú†", romaji: "yu" },
    { hira: "„Çà", hangul: "Ïöî", romaji: "yo" },

    { hira: "„Çâ", hangul: "Îùº", romaji: "ra" },
    { hira: "„Çä", hangul: "Î¶¨", romaji: "ri" },
    { hira: "„Çã", hangul: "Î£®", romaji: "ru" },
    { hira: "„Çå", hangul: "Î†à", romaji: "re" },
    { hira: "„Çç", hangul: "Î°ú", romaji: "ro" },

    { hira: "„Çè", hangul: "ÏôÄ", romaji: "wa" },
    { hira: "„Çì", hangul: "Ïùë", romaji: "n" },
  ];

  const hiraToPair = new Map(PAIRS.map(p => [p.hira, p]));
  const hangulToPair = new Map(PAIRS.map(p => [p.hangul, p]));

  function randInt(n){ return (Math.random()*n)|0; }
  function choice(arr){ return arr[randInt(arr.length)]; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // ---------------------------
  // 2) CANVAS
  // ---------------------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  let W = 0, H = 0;

  // Layout: 3:2 (portrait) playfield + bottom control area
  const layout = {
    pad: 14,
    controlH: 180,
    field: { x:0, y:0, w:0, h:0 }, // w:h = 2:3
  };

  // ---------------------------
  // 3) THEME
  // ---------------------------
  const COLOR_BG = "#0b0f16";
  const COLOR_TEXT = "#e9eef8";
  const COLOR_TEXT_DIM = "rgba(233,238,248,0.75)";
  const COLOR_STROKE = "rgba(5,8,12,0.85)";
  const COLOR_PLAYER_FILL = "#f1f6ff";
  const COLOR_PLAYER_TEXT = "#141a24";
  const COLOR_HINT_GREEN = "rgba(168, 255, 120, 0.95)"; // Ïó∞ÎëêÏÉâ

  // ---------------------------
  // 4) GAME STATE
  // ---------------------------
  const STATE = { START: "start", PLAY: "play", OVER: "over" };
  let state = STATE.START;

  // World coords inside field rectangle: [0..Fw], [0..Fh]
  function toScreen(wx, wy){
    return { x: layout.field.x + wx, y: layout.field.y + wy };
  }

  // Player
  const player = {
    x: 0, y: 0,
    vx: 0, vy: 0,        // ‚úÖ ÎäêÎ¶∞ ÏµúÎåÄÏÜçÎèÑ + Îπ†Î•∏ Î∞òÏùëÏùÑ ÏúÑÌïú ÏÜçÎèÑ Î≤°ÌÑ∞
    r: 18,
    speed: 200,          // will be set in layout
    char: "ÏïÑ",

    invincible: false,
    blinkT: 0,
    blinkTotal: 0,
    blinkCount: 0,
    blinkMax: 10,
    blinkInterval: 0.198,
    blinkShowAlt: false,
    blinkA: "ÏïÑ",
    blinkB: "„ÅÇ",
  };

  // Joystick
  const joy = {
    active: false,
    pointerId: null,
    baseX: 0, baseY: 0,
    knobX: 0, knobY: 0,
    baseR: 56,
    knobR: 24,
    dx: 0, dy: 0,
    area: { x:0, y:0, w:0, h:0 }
  };

  // UI rects for start screen buttons
  const ui = {
    startBtn: { x:0,y:0,w:0,h:0 },
    helpBtn:  { x:0,y:0,w:0,h:0 },
    helpOpen: false,
    helpPanel: { x:0,y:0,w:0,h:0 }
  };

  // Scale helper (mobile-first)
  function sp(px){
    const k = clamp((layout.field.w || 320) / 320, 0.98, 1.85);
    return Math.round(px * k);
  }

  let lives = 3;
  let score = 0;

  // Difficulty timers
  let timeAlive = 0; // spawn/max bullets
  let speedTime = 0; // bullet speed ramp (resets on hit)

  // Hint effect
  let highlightCorrect = false; // ? eaten => true; reset when correct eaten OR hit/death/restart

  // Bullets
  // {x,y,vx,vy,text,pair,r,isHint}
  const bullets = [];
  let spawnAcc = 0;
  let spawnRate = 0.8;  // half-ish baseline (will be adjusted in tick)
  let maxBullets = 90;  // baseline (will be adjusted in tick)

  // Aura (correct eat clears nearby bullets)
  let auraT = 0;
  const auraDuration = 0.6;
  let auraRadius = 120;

  const mistakes = new Map();

  function isPlayerHangul() { return hangulToPair.has(player.char); }
  function getPlayerPair() { return isPlayerHangul() ? hangulToPair.get(player.char) : hiraToPair.get(player.char); }

  function setRandomPlayerChar(avoidChar=null) {
    const p = choice(PAIRS);
    const pickHangul = Math.random() < 0.5;
    const next = pickHangul ? p.hangul : p.hira;
    player.char = (next === avoidChar) ? (pickHangul ? p.hira : p.hangul) : next;
  }

  function currentCorrectText() {
    const pp = getPlayerPair();
    return isPlayerHangul() ? pp.hira : pp.hangul;
  }

  function addMistake(pair) {
    const key = pair.hira + "|" + pair.hangul;
    const cur = mistakes.get(key);
    if (cur) cur.count += 1;
    else mistakes.set(key, { pair, count: 1 });
  }

  function clearAllBullets() {
    bullets.length = 0;
    spawnAcc = 0;
  }

  function clearBulletsNearPlayer() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      const d = Math.hypot(b.x - player.x, b.y - player.y);
      if (d <= auraRadius) bullets.splice(i, 1);
    }
  }

  function onEatCorrect(pair) {
    score += 120;
    auraT = auraDuration;
    clearBulletsNearPlayer();

    // hint effect resets when correct is eaten
    highlightCorrect = false;

    setRandomPlayerChar(player.char);
  }

  function startInvincibleBlink() {
    const pp = getPlayerPair();
    player.blinkA = pp.hangul;
    player.blinkB = pp.hira;

    player.invincible = true;
    player.blinkT = 0;
    player.blinkCount = 0;
    player.blinkShowAlt = false;
    player.blinkTotal = player.blinkMax * player.blinkInterval;
  }

  function onHitWrong(pairWrong) {
    lives -= 1;
    addMistake(pairWrong);
    score = Math.max(0, score - 80);

    // hit resets hint and clears all bullets
    highlightCorrect = false;
    clearAllBullets();

    // also stop player immediately (feels crisp)
    player.vx = 0;
    player.vy = 0;

    if (lives <= 0) {
      state = STATE.OVER;
      return;
    }

    // reset speed ramp
    speedTime = 0;
    startInvincibleBlink();
  }

  // ---------------------------
  // 5) LAYOUT / RESIZE (3:2 portrait)
  // ---------------------------
  function updateJoystickLayout(){
    const yTop = layout.field.y + layout.field.h + layout.pad;
    const areaH = H - yTop;

    joy.baseR = clamp(sp(56), 46, 78);
    joy.knobR = clamp(Math.round(joy.baseR * 0.42), 18, 34);

    joy.area.x = 0;
    joy.area.y = yTop;
    joy.area.w = W;
    joy.area.h = areaH;

    // joystick x rule: center on phones, lock from right when wider
    const PHONE_W = 420;
    const centerX = W / 2;
    const lockFromRight = PHONE_W / 2;
    const lockedX = W - lockFromRight;

    let targetX = (W <= PHONE_W) ? centerX : lockedX;
    const minX = layout.pad + joy.baseR;
    const maxX = W - layout.pad - joy.baseR;
    targetX = clamp(targetX, minX, maxX);

    joy.baseX = targetX;
    joy.baseY = yTop + areaH/2;

    if (!joy.active) {
      joy.knobX = joy.baseX;
      joy.knobY = joy.baseY;
    }

    // scale player + aura
    player.r = clamp(sp(22), 18, 32);

    // ‚úÖ ÏµúÎåÄÏÜçÎèÑÎäî "ÏßÄÍ∏àÎ≥¥Îã§ ÎäêÎ¶¨Í≤å" (Ïù¥Ï†Ñ ÎåÄÎπÑ down)
    player.speed = clamp(layout.field.w * 0.50, 180, 280);

    auraRadius = clamp(layout.field.w * 0.50, 120, 240);
  }

  function resize() {
    const vw = (window.visualViewport?.width ?? innerWidth);
    const vh = (window.visualViewport?.height ?? innerHeight);

    W = Math.floor(vw);
    H = Math.floor(vh);

    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);

    layout.controlH = clamp(Math.round(H * 0.26), 160, 270);

    const usableH = H - layout.controlH - layout.pad*2;
    const usableW = W - layout.pad*2;

    // w:h = 2:3 => h = 1.5w
    const w = Math.max(260, Math.min(usableW, usableH / 1.5));
    const h = w * 1.5;

    layout.field.w = Math.floor(w);
    layout.field.h = Math.floor(h);
    layout.field.x = Math.floor((W - layout.field.w) / 2);
    layout.field.y = layout.pad;

    updateJoystickLayout();
  }

  addEventListener("resize", resize);
  if (window.visualViewport) window.visualViewport.addEventListener("resize", resize);
  resize();

  // ---------------------------
  // 6) JOYSTICK INPUT (responsive curve)
  // ---------------------------
  function resetJoystick(){
    joy.active = false;
    joy.pointerId = null;
    joy.dx = 0; joy.dy = 0;
    joy.knobX = joy.baseX;
    joy.knobY = joy.baseY;
  }

  function setJoystickFromPointer(sx, sy){
    const dx = sx - joy.baseX;
    const dy = sy - joy.baseY;
    const dist = Math.hypot(dx,dy) || 1;
    const max = joy.baseR - joy.knobR;

    const t = Math.min(1, dist / max);
    const kx = joy.baseX + (dx/dist) * max * t;
    const ky = joy.baseY + (dy/dist) * max * t;

    joy.knobX = kx;
    joy.knobY = ky;

    let ndx = (kx - joy.baseX) / max;
    let ndy = (ky - joy.baseY) / max;

    // responsiveness near center
    const mag = clamp(Math.hypot(ndx, ndy), 0, 1);
    if (mag > 0.0001) {
      const curved = Math.pow(mag, 0.70);
      const s = curved / mag;
      ndx *= s; ndy *= s;
    }

    joy.dx = ndx;
    joy.dy = ndy;
  }

  function isInJoystickArea(sx, sy){
    return sx >= joy.area.x && sx <= joy.area.x + joy.area.w
        && sy >= joy.area.y && sy <= joy.area.y + joy.area.h;
  }

  function inRect(px, py, r){
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  canvas.addEventListener("pointerdown", (ev) => {
    ev.preventDefault();
    const sx = ev.clientX, sy = ev.clientY;

    if (state === STATE.START) {
      if (inRect(sx, sy, ui.helpBtn)) {
        ui.helpOpen = !ui.helpOpen;
        return;
      }
      if (ui.helpOpen && inRect(sx, sy, ui.helpPanel) === false) {
        ui.helpOpen = false;
        return;
      }
      if (inRect(sx, sy, ui.startBtn)) {
        startGame();
      }
      return;
    }

    if (state === STATE.OVER) {
      startGame();
      return;
    }

    if (isInJoystickArea(sx, sy) && !joy.active) {
      joy.active = true;
      joy.pointerId = ev.pointerId;
      canvas.setPointerCapture(ev.pointerId);
      setJoystickFromPointer(sx, sy);
    }
  }, { passive:false });

  canvas.addEventListener("pointermove", (ev) => {
    if (state !== STATE.PLAY) return;
    if (!joy.active || ev.pointerId !== joy.pointerId) return;
    ev.preventDefault();
    setJoystickFromPointer(ev.clientX, ev.clientY);
  }, { passive:false });

  canvas.addEventListener("pointerup", (ev) => { if (ev.pointerId === joy.pointerId) resetJoystick(); });
  canvas.addEventListener("pointercancel", (ev) => { if (ev.pointerId === joy.pointerId) resetJoystick(); });

  // ---------------------------
  // 7) SPAWN (adjusted frequencies)
  // ---------------------------
  function spawnBullet() {
    if (bullets.length >= maxBullets) return;

    const Fw = layout.field.w;
    const Fh = layout.field.h;

    // ‚úÖ ? ÎπàÎèÑ: Ïù¥Ï†Ñ(0.05/0.02)Ïùò 1/3
    const hintChance = highlightCorrect ? 0.002 : 0.02;
    const isHint = Math.random() < hintChance;

    let pair;
    let text;

    if (isHint) {
      pair = null;
      text = "?";
    } else {
      // ‚úÖ Ï†ïÎãµ ÎπàÎèÑ
      const correctPair = getPlayerPair();
      const correctChance = 0.2;

      if (Math.random() < correctChance) {
        pair = correctPair;
      } else {
        do { pair = choice(PAIRS); } while (pair === correctPair);
      }

      const wantHiraBullets = isPlayerHangul();
      text = wantHiraBullets ? pair.hira : pair.hangul;
    }

    // Spawn from random edge
    const edge = randInt(4);
    const pad = 12;
    let x, y;
    if (edge === 0) { x = Math.random()*Fw; y = -pad; }
    else if (edge === 1) { x = Fw+pad; y = Math.random()*Fh; }
    else if (edge === 2) { x = Math.random()*Fw; y = Fh+pad; }
    else { x = -pad; y = Math.random()*Fh; }

    // Move toward player
    const dx = (player.x - x);
    const dy = (player.y - y);
    const dist = Math.max(0.001, Math.hypot(dx,dy));
    const dirx = dx/dist, diry = dy/dist;

    const base = 60 + Math.min(260, speedTime * 2);
    const jitter = (Math.random()*26 - 13);
    const speed = base + jitter;

    const r = clamp(Math.round(Fw*0.045), 14, 22);
    bullets.push({ x, y, vx: dirx*speed, vy: diry*speed, text, pair, r, isHint });
  }

  function startGame(){
    state = STATE.PLAY;
    ui.helpOpen = false;

    bullets.length = 0;
    mistakes.clear();

    lives = 3;
    score = 0;
    timeAlive = 0;
    speedTime = 0;

    spawnAcc = 0;
    // baseline; tick will update
    spawnRate = 0.8;
    maxBullets = 90;

    auraT = 0;
    player.invincible = false;

    highlightCorrect = false;

    const Fw = layout.field.w;
    const Fh = layout.field.h;
    player.x = Fw*0.5;
    player.y = Fh*0.68;
    player.vx = 0;
    player.vy = 0;

    setRandomPlayerChar(null);
    resetJoystick();
  }

  // ---------------------------
  // 8) RENDER
  // ---------------------------
  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawTextWithStroke(text, x, y, fontPx, fill, stroke, strokeW=2) {
    ctx.font = `900 ${fontPx}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", "Apple SD Gothic Neo", sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineWidth = strokeW;
    ctx.strokeStyle = stroke;
    ctx.fillStyle = fill;
    ctx.strokeText(text, x, y);
    ctx.fillText(text, x, y);
  }

  function renderFieldFrame(){
    ctx.strokeStyle = "rgba(233,238,248,0.10)";
    ctx.lineWidth = 1;
    roundRect(ctx, layout.field.x, layout.field.y, layout.field.w, layout.field.h, sp(16));
    ctx.stroke();
  }

  function renderHUD(){
    const pad = sp(12);

    ctx.save();
    ctx.beginPath();
    ctx.rect(layout.field.x, layout.field.y, layout.field.w, layout.field.h);
    ctx.clip();

    ctx.fillStyle = "rgba(233,238,248,0.92)";
    ctx.font = `700 ${clamp(sp(14), 13, 20)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    ctx.fillText(`Ï†êÏàò: ${Math.floor(score)}`, layout.field.x + pad, layout.field.y + pad);
    ctx.fillText(`Î™©Ïà®: ${"‚óè".repeat(lives)}${"‚óã".repeat(Math.max(0,3-lives))}`, layout.field.x + pad, layout.field.y + pad + sp(20));

    ctx.restore();
  }

  function renderJoystick(){
    const yTop = joy.area.y;
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(0, yTop, W, joy.area.h);

    ctx.beginPath();
    ctx.arc(joy.baseX, joy.baseY, joy.baseR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(233,238,248,0.06)";
    ctx.fill();
    ctx.strokeStyle = "rgba(233,238,248,0.14)";
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(joy.knobX, joy.knobY, joy.knobR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(233,238,248,0.18)";
    ctx.fill();
    ctx.strokeStyle = "rgba(233,238,248,0.24)";
    ctx.stroke();
  }

  function computeStartUIRects(){
    const centerX = W/2;
    const baseY = layout.field.y + layout.field.h * 0.60;

    const bw = clamp(sp(190), 160, 260);
    const bh = clamp(sp(56), 48, 70);
    const bx = centerX - bw/2;
    const by = baseY - bh/2;
    ui.startBtn = { x: bx, y: by, w: bw, h: bh };

    const hw = clamp(sp(150), 130, 230);
    const hh = clamp(sp(44), 38, 58);
    const hx = centerX - hw/2;
    const hy = by + bh + sp(14);
    ui.helpBtn = { x: hx, y: hy, w: hw, h: hh };

    const pw = Math.min(layout.field.w - sp(26), sp(560));
    const ph = Math.min(layout.field.h * 0.55, sp(420));
    const px = W/2 - pw/2;
    const py = layout.field.y + layout.field.h*0.16;
    ui.helpPanel = { x:px, y:py, w:pw, h:ph };
  }

  function renderHelpPanel(){
    const p = ui.helpPanel;

    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.strokeStyle = "rgba(233,238,248,0.18)";
    ctx.lineWidth = 1;
    roundRect(ctx, p.x, p.y, p.w, p.h, sp(16));
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "rgba(233,238,248,0.92)";
    ctx.font = `900 ${clamp(sp(16), 14, 22)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("ÎèÑÏõÄÎßê", p.x + sp(14), p.y + sp(12));

    ctx.fillStyle = COLOR_TEXT_DIM;
    ctx.font = `650 ${clamp(sp(14), 13, 20)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;

    const lines = [
      "‚Ä¢ Ïõê Ïïà Í∏ÄÏûêÏôÄ ÏßùÏù¥ ÎêòÎäî Í∏ÄÏûêÎßå Î®πÍ∏∞",
      "‚Ä¢ ÌãÄÎ¶¨Î©¥ Î™©Ïà® -1 (Î¨¥Ï†Å ÍπúÎπ°ÏûÑ)",
      "‚Ä¢ Ï†ïÎãµÏùÑ Î®πÏúºÎ©¥ Ï£ºÎ≥Ä ÌÉÑÎßâÏù¥ Ïû†Ïãú ÏÇ¨ÎùºÏßê",
      "‚Ä¢ ? Îäî ÌûåÌä∏ ÏïÑÏù¥ÌÖú: Î®πÏúºÎ©¥ Ï†ïÎãµÎßå Ïó∞ÎëêÏÉâ ÌëúÏãú",
      "   (Ï†ïÎãµÏùÑ Î®πÍ±∞ÎÇò ÎßûÏúºÎ©¥ Ìö®Í≥º Ìï¥Ï†ú)",
      "",
      "Îã´Í∏∞: ÎèÑÏõÄÎßê Î≤ÑÌäº ÎòêÎäî Ìå®ÎÑê Î∞ñ ÌÉ≠"
    ];

    let y = p.y + sp(48);
    for (const s of lines){
      ctx.fillText(s, p.x + sp(14), y);
      y += sp(22);
    }
  }

  function renderStart(){
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "rgba(255,255,255,0.01)";
    ctx.fillRect(layout.field.x, layout.field.y, layout.field.w, layout.field.h);
    renderFieldFrame();

    computeStartUIRects();

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(233,238,248,0.95)";
    ctx.font = `900 ${clamp(sp(34), 28, 46)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("ÌûàÎùºÍ∞ÄÎÇò ÌäπÌõà", W/2, layout.field.y + layout.field.h*0.30);

    // Start button
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.strokeStyle = "rgba(233,238,248,0.18)";
    ctx.lineWidth = 1;
    roundRect(ctx, ui.startBtn.x, ui.startBtn.y, ui.startBtn.w, ui.startBtn.h, sp(16));
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(233,238,248,0.92)";
    ctx.font = `900 ${clamp(sp(22), 18, 30)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("ÏãúÏûë", W/2, ui.startBtn.y + ui.startBtn.h/2);

    // Help button
    ctx.fillStyle = "rgba(255,255,255,0.04)";
    ctx.strokeStyle = "rgba(233,238,248,0.14)";
    roundRect(ctx, ui.helpBtn.x, ui.helpBtn.y, ui.helpBtn.w, ui.helpBtn.h, sp(14));
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(233,238,248,0.88)";
    ctx.font = `800 ${clamp(sp(18), 16, 26)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText(ui.helpOpen ? "ÎèÑÏõÄÎßê Îã´Í∏∞" : "ÎèÑÏõÄÎßê", W/2, ui.helpBtn.y + ui.helpBtn.h/2);

    renderJoystick();
    if (ui.helpOpen) renderHelpPanel();
  }

  function renderOver(){
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "rgba(255,255,255,0.01)";
    ctx.fillRect(layout.field.x, layout.field.y, layout.field.w, layout.field.h);
    renderFieldFrame();

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(233,238,248,0.95)";
    ctx.font = `900 ${clamp(sp(34), 28, 46)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("Í≤åÏûÑ Ïò§Î≤Ñ", W/2, layout.field.y + layout.field.h*0.20);

    ctx.fillStyle = COLOR_TEXT_DIM;
    ctx.font = `700 ${clamp(sp(18), 16, 26)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText(`ÏµúÏ¢Ö Ï†êÏàò: ${Math.floor(score)}`, W/2, layout.field.y + layout.field.h*0.28);

    const arr = Array.from(mistakes.values()).sort((a,b)=>b.count-a.count).slice(0, 10);
    const boxW = Math.min(layout.field.w - sp(24), sp(620));
    const boxX = W/2 - boxW/2;
    const boxY = layout.field.y + layout.field.h*0.34;
    const rowH = clamp(sp(26), 22, 34);
    const boxH = sp(46) + Math.max(1, arr.length) * rowH + sp(48);

    ctx.fillStyle = "rgba(255,255,255,0.04)";
    ctx.strokeStyle = "rgba(233,238,248,0.14)";
    roundRect(ctx, boxX, boxY, boxW, boxH, sp(16));
    ctx.fill(); ctx.stroke();

    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillStyle = "rgba(233,238,248,0.92)";
    ctx.font = `800 ${clamp(sp(16), 14, 22)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("ÌãÄÎ¶∞ Î™©Î°ù / Ï†ïÎãµ (Î°úÎßàÏûê Ìè¨Ìï®)", boxX + sp(14), boxY + sp(12));

    ctx.fillStyle = COLOR_TEXT_DIM;
    ctx.font = `650 ${clamp(sp(15), 13, 20)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;

    if (arr.length === 0) {
      ctx.fillText("ÌãÄÎ¶∞ Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§! üéâ", boxX + sp(14), boxY + sp(42));
    } else {
      let y = boxY + sp(42);
      for (const it of arr) {
        const p = it.pair;
        ctx.fillText(`‚Ä¢ ${p.hira} ‚Üî ${p.hangul} (${p.romaji}) √ó${it.count}`, boxX + sp(14), y);
        y += rowH;
      }
    }

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(233,238,248,0.9)";
    ctx.font = `900 ${clamp(sp(18), 16, 26)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("ÌÉ≠Ìï¥ÏÑú Ïû¨ÎèÑÏ†Ñ", W/2, boxY + boxH + sp(26));

    renderJoystick();
  }

  function renderPlay(){
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "rgba(255,255,255,0.01)";
    ctx.fillRect(layout.field.x, layout.field.y, layout.field.w, layout.field.h);
    renderFieldFrame();

    ctx.save();
    ctx.beginPath();
    ctx.rect(layout.field.x, layout.field.y, layout.field.w, layout.field.h);
    ctx.clip();

    // aura
    if (auraT > 0) {
      const t = auraT / auraDuration;
      const ps = toScreen(player.x, player.y);
      ctx.beginPath();
      ctx.arc(ps.x, ps.y, auraRadius * (1 - t*0.15), 0, Math.PI*2);
      ctx.strokeStyle = `rgba(233,238,248,${0.08 + 0.12*t})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    const correctText = currentCorrectText();

    const bulletFont = clamp(sp(30), 24, 46);
    for (const b of bullets) {
      const s = toScreen(b.x, b.y);

      const isCorrectNow = (!b.isHint && b.text === correctText);
      let fill = COLOR_TEXT;
      if (b.isHint) fill = "rgba(255,255,255,0.92)";
      else if (highlightCorrect && isCorrectNow) fill = COLOR_HINT_GREEN;

      drawTextWithStroke(b.text, s.x, s.y, bulletFont, fill, COLOR_STROKE, 2);
    }

    // player
    const ps = toScreen(player.x, player.y);
    const alpha = player.invincible ? (player.blinkShowAlt ? 0.35 : 1.0) : 1.0;

    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.fillStyle = COLOR_PLAYER_FILL;
    ctx.arc(ps.x, ps.y, player.r, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    let pChar = player.char;
    if (player.invincible) pChar = player.blinkShowAlt ? player.blinkB : player.blinkA;

    ctx.font = `900 ${clamp(Math.round(player.r*1.10), 20, 36)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = COLOR_PLAYER_TEXT;
    ctx.fillText(pChar, ps.x, ps.y);

    if (player.invincible) {
      const pulse = 1 + 0.08 * Math.sin(performance.now() * 0.02);
      ctx.beginPath();
      ctx.arc(ps.x, ps.y, player.r * 1.25 * pulse, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(233,238,248,0.32)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.restore();

    renderHUD();
    renderJoystick();
  }

  function render(){
    if (state === STATE.START) renderStart();
    else if (state === STATE.PLAY) renderPlay();
    else renderOver();
  }

  // ---------------------------
  // 9) UPDATE LOOP
  // ---------------------------
  let lastT = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - lastT) / 1000);
    lastT = now;

    if (state === STATE.PLAY) {
      timeAlive += dt;

      // Allow spawn only after blinkCount >= 4
      const allowSpawn = !(player.invincible && player.blinkCount < 4);
      if (allowSpawn) speedTime += dt;

      // ‚úÖ total bullets: 2/3 of previous (147 cap, 60 base, 1.0 growth)
      spawnRate = Math.min(5.0, 0.8 + timeAlive * 0.04); // keep density feel; cap is handled by maxBullets
      maxBullets = Math.min(147, 60 + Math.floor(timeAlive * 1.0));

      if (!allowSpawn) {
        if (bullets.length) bullets.length = 0;
        spawnAcc = 0;
      } else {
        spawnAcc += dt * spawnRate;
        while (spawnAcc >= 1) { spawnAcc -= 1; spawnBullet(); }
      }

      // movement: slower max speed, faster response
      const Fw = layout.field.w;
      const Fh = layout.field.h;

      const mag = clamp(Math.hypot(joy.dx, joy.dy), 0, 1);

      const targetVx = joy.dx * player.speed * mag;
      const targetVy = joy.dy * player.speed * mag;

      // ‚úÖ crisp response while moving slower
      const accel = 22;
      const stopFriction = 26;

      if (mag > 0.02) {
        const a = (1 - Math.exp(-accel * dt));
        player.vx += (targetVx - player.vx) * a;
        player.vy += (targetVy - player.vy) * a;
      } else {
        const f = Math.exp(-stopFriction * dt);
        player.vx *= f;
        player.vy *= f;
      }

      player.x += player.vx * dt;
      player.y += player.vy * dt;

      player.x = clamp(player.x, player.r, Fw - player.r);
      player.y = clamp(player.y, player.r, Fh - player.r);

      // invincible blink
      if (player.invincible) {
        player.blinkT += dt;
        const toggles = Math.floor(player.blinkT / player.blinkInterval);
        if (toggles > player.blinkCount) {
          player.blinkCount = toggles;
          player.blinkShowAlt = !player.blinkShowAlt;
        }
        if (player.blinkT >= player.blinkTotal) {
          player.invincible = false;
          setRandomPlayerChar(player.char);
        }
      }

      if (auraT > 0) auraT = Math.max(0, auraT - dt);

      // bullets update + collision
      const correctText = currentCorrectText();
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if (!b) continue;

        b.x += b.vx * dt;
        b.y += b.vy * dt;

        if (b.x < -80 || b.x > Fw+80 || b.y < -80 || b.y > Fh+80) {
          bullets.splice(i,1);
          continue;
        }

        const d = Math.hypot(b.x - player.x, b.y - player.y);
        if (d <= b.r + player.r) {
          bullets.splice(i,1);

          if (b.isHint) {
            highlightCorrect = true;
            continue;
          }

          const isCorrect = (b.text === correctText);
          if (isCorrect) {
            onEatCorrect(b.pair);
          } else if (!player.invincible) {
            onHitWrong(b.pair);
            break; // onHitWrong clears bullets
          }
        }
      }

      score += dt * 8;
    }

    render();
    requestAnimationFrame(tick);
  }

  resetJoystick();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
