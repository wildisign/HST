<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>íˆë¼ê°€ë‚˜ íŠ¹í›ˆ</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f16; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    body { user-select:none; -webkit-user-select:none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  // ---------------------------
  // 1) DATA
  // ---------------------------
  const PAIRS = [
    { hira: "ã‚", hangul: "ì•„", romaji: "a" },
    { hira: "ã„", hangul: "ì´", romaji: "i" },
    { hira: "ã†", hangul: "ìš°", romaji: "u" },
    { hira: "ãˆ", hangul: "ì—", romaji: "e" },
    { hira: "ãŠ", hangul: "ì˜¤", romaji: "o" },

    { hira: "ã‹", hangul: "ì¹´", romaji: "ka" },
    { hira: "ã", hangul: "í‚¤", romaji: "ki" },
    { hira: "ã", hangul: "ì¿ ", romaji: "ku" },
    { hira: "ã‘", hangul: "ì¼€", romaji: "ke" },
    { hira: "ã“", hangul: "ì½”", romaji: "ko" },

    { hira: "ã•", hangul: "ì‚¬", romaji: "sa" },
    { hira: "ã—", hangul: "ì‹œ", romaji: "shi" },
    { hira: "ã™", hangul: "ìŠ¤", romaji: "su" },
    { hira: "ã›", hangul: "ì„¸", romaji: "se" },
    { hira: "ã", hangul: "ì†Œ", romaji: "so" },

    { hira: "ãŸ", hangul: "íƒ€", romaji: "ta" },
    { hira: "ã¡", hangul: "ì¹˜", romaji: "chi" },
    { hira: "ã¤", hangul: "ì¸ ", romaji: "tsu" },
    { hira: "ã¦", hangul: "í…Œ", romaji: "te" },
    { hira: "ã¨", hangul: "í† ", romaji: "to" },

    { hira: "ãª", hangul: "ë‚˜", romaji: "na" },
    { hira: "ã«", hangul: "ë‹ˆ", romaji: "ni" },
    { hira: "ã¬", hangul: "ëˆ„", romaji: "nu" },
    { hira: "ã­", hangul: "ë„¤", romaji: "ne" },
    { hira: "ã®", hangul: "ë…¸", romaji: "no" },

    { hira: "ã¯", hangul: "í•˜", romaji: "ha" },
    { hira: "ã²", hangul: "íˆ", romaji: "hi" },
    { hira: "ãµ", hangul: "í›„", romaji: "fu" },
    { hira: "ã¸", hangul: "í—¤", romaji: "he" },
    { hira: "ã»", hangul: "í˜¸", romaji: "ho" },

    { hira: "ã¾", hangul: "ë§ˆ", romaji: "ma" },
    { hira: "ã¿", hangul: "ë¯¸", romaji: "mi" },
    { hira: "ã‚€", hangul: "ë¬´", romaji: "mu" },
    { hira: "ã‚", hangul: "ë©”", romaji: "me" },
    { hira: "ã‚‚", hangul: "ëª¨", romaji: "mo" },

    { hira: "ã‚„", hangul: "ì•¼", romaji: "ya" },
    { hira: "ã‚†", hangul: "ìœ ", romaji: "yu" },
    { hira: "ã‚ˆ", hangul: "ìš”", romaji: "yo" },

    { hira: "ã‚‰", hangul: "ë¼", romaji: "ra" },
    { hira: "ã‚Š", hangul: "ë¦¬", romaji: "ri" },
    { hira: "ã‚‹", hangul: "ë£¨", romaji: "ru" },
    { hira: "ã‚Œ", hangul: "ë ˆ", romaji: "re" },
    { hira: "ã‚", hangul: "ë¡œ", romaji: "ro" },

    { hira: "ã‚", hangul: "ì™€", romaji: "wa" },
    { hira: "ã‚“", hangul: "ì‘", romaji: "n" },
  ];

  const hiraToPair = new Map(PAIRS.map(p => [p.hira, p]));
  const hangulToPair = new Map(PAIRS.map(p => [p.hangul, p]));

  function randInt(n){ return (Math.random()*n)|0; }
  function choice(arr){ return arr[randInt(arr.length)]; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // ---------------------------
  // 2) CANVAS
  // ---------------------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  let W = 0, H = 0;

  const layout = {
    pad: 14,
    controlH: 170,
    field: { x:0, y:0, s:0 },
  };

  // ---------------------------
  // 3) THEME
  // ---------------------------
  const COLOR_BG = "#0b0f16";
  const COLOR_TEXT = "#e9eef8";
  const COLOR_TEXT_DIM = "rgba(233,238,248,0.75)";
  const COLOR_STROKE = "rgba(5,8,12,0.85)";
  const COLOR_PLAYER_FILL = "#f1f6ff";
  const COLOR_PLAYER_TEXT = "#141a24";

  // ---------------------------
  // 4) STATE
  // ---------------------------
  const STATE = { START: "start", PLAY: "play", OVER: "over" };
  let state = STATE.START;

  function toScreen(wx, wy){
    return { x: layout.field.x + wx, y: layout.field.y + wy };
  }

  const player = {
    x: 0, y: 0,
    r: 18,
    speed: 210,
    char: "ì•„",

    invincible: false,
    blinkT: 0,
    blinkTotal: 0,
    blinkCount: 0,      // number of toggles elapsed
    blinkMax: 10,       // âœ… 10íšŒ (íˆë¼5/í•œê¸€5)
    blinkInterval: 0.198, // âœ… 0.18ì—ì„œ 10% ëŠë¦¬ê²Œ
    blinkShowAlt: false,
    blinkA: "ì•„",
    blinkB: "ã‚",
  };

  const joy = {
    active: false,
    pointerId: null,
    baseX: 0, baseY: 0,
    knobX: 0, knobY: 0,
    baseR: 54,
    knobR: 22,
    dx: 0, dy: 0,
    area: { x:0, y:0, w:0, h:0 }
  };

  // âœ… ëª¨ë°”ì¼ ê¸€ì í¬ê¸° í‚¤ìš°ê¸°: ê¸°ì¤€ì„ 360ì´ ì•„ë‹ˆë¼ 320ìœ¼ë¡œ ì¡ê³ ,
  // ìŠ¤ì¼€ì¼ ìƒí•œë„ ì¡°ê¸ˆ ì˜¬ë¦¼
  function sp(px){
    const s = layout.field.s || 360;
    const k = clamp(s / 320, 0.95, 1.70); // í°ì—ì„œ ì¢€ ë” í¼, íƒœë¸”ë¦¿ë„ ì¶©ë¶„íˆ ì»¤ì§
    return Math.round(px * k);
  }

  let lives = 3;
  let score = 0;

  // ë‚œì´ë„ íƒ€ì´ë¨¸
  let timeAlive = 0;      // ìŠ¤í°/ìµœëŒ€íƒ„ë§‰ìš©(ê·¸ëŒ€ë¡œ)
  let speedTime = 0;      // âœ… íƒ„ë§‰ ì†ë„ ì¦ê°€ìš©(í”¼ê²© í›„ ë¦¬ì…‹)

  const bullets = [];
  let spawnAcc = 0;
  let spawnRate = 1.6;
  let maxBullets = 180;

  let auraT = 0;
  const auraDuration = 0.6;
  let auraRadius = 110;

  const mistakes = new Map();

  function isPlayerHangul() { return hangulToPair.has(player.char); }
  function getPlayerPair() { return isPlayerHangul() ? hangulToPair.get(player.char) : hiraToPair.get(player.char); }

  function setRandomPlayerChar(avoidChar=null) {
    const p = choice(PAIRS);
    const pickHangul = Math.random() < 0.5;
    const next = pickHangul ? p.hangul : p.hira;
    player.char = (next === avoidChar) ? (pickHangul ? p.hira : p.hangul) : next;
  }

  function currentCorrectText() {
    const pp = getPlayerPair();
    return isPlayerHangul() ? pp.hira : pp.hangul;
  }

  function addMistake(pair) {
    const key = pair.hira + "|" + pair.hangul;
    const cur = mistakes.get(key);
    if (cur) cur.count += 1;
    else mistakes.set(key, { pair, count: 1 });
  }

  function clearAllBullets() {
    bullets.length = 0;
    spawnAcc = 0;
  }

  function clearBulletsNearPlayer() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      const d = Math.hypot(b.x - player.x, b.y - player.y);
      if (d <= auraRadius) bullets.splice(i, 1);
    }
  }

  function onEatCorrect(pair) {
    score += 120;
    auraT = auraDuration;
    clearBulletsNearPlayer();
    setRandomPlayerChar(player.char);
  }

  function startInvincibleBlink() {
    const pp = getPlayerPair();
    player.blinkA = pp.hangul;
    player.blinkB = pp.hira;

    player.invincible = true;
    player.blinkT = 0;
    player.blinkCount = 0;
    player.blinkShowAlt = false;
    player.blinkTotal = player.blinkMax * player.blinkInterval;
  }

  function onHitWrong(pairWrong) {
    lives -= 1;
    addMistake(pairWrong);
    score = Math.max(0, score - 80);

    // âœ… í”¼ê²© ìˆœê°„: ì „ì²´ íƒ„ë§‰ ì œê±°
    clearAllBullets();

    if (lives <= 0) {
      state = STATE.OVER;
      return;
    }

    // âœ… ì†ë„ íƒ€ì´ë¨¸ ë¦¬ì…‹ (íƒ„ë§‰ ì¬ì§„ì… ì‹œ "ì´ˆê¸° ì†ë„"ë¡œ ì‹œì‘í•˜ê²Œ)
    speedTime = 0;

    startInvincibleBlink();
  }

  // ---------------------------
  // 5) LAYOUT / RESIZE
  // ---------------------------
  function updateJoystickLayout(){
    const yTop = layout.field.y + layout.field.s + layout.pad;
    const areaH = H - yTop;

    joy.baseR = clamp(sp(56), 46, 74);
    joy.knobR = clamp(Math.round(joy.baseR * 0.42), 18, 32);

    joy.area.x = 0;
    joy.area.y = yTop;
    joy.area.w = W;
    joy.area.h = areaH;

    // ì¡°ì´ìŠ¤í‹± ìœ„ì¹˜ ê·œì¹™(ì´ì „ ìš”êµ¬ ìœ ì§€)
    const PHONE_W = 420;
    const centerX = W / 2;
    const lockFromRight = PHONE_W / 2; // 210
    const lockedX = W - lockFromRight;

    let targetX = (W <= PHONE_W) ? centerX : lockedX;

    const minX = layout.pad + joy.baseR;
    const maxX = W - layout.pad - joy.baseR;
    targetX = clamp(targetX, minX, maxX);

    joy.baseX = targetX;
    joy.baseY = yTop + areaH/2;

    if (!joy.active) {
      joy.knobX = joy.baseX;
      joy.knobY = joy.baseY;
    }

    player.r = clamp(sp(22), 18, 30);
    player.speed = clamp(layout.field.s * 0.58, 190, 340);
    auraRadius = clamp(layout.field.s * 0.30, 100, 190);
  }

  function resize() {
    const vw = (window.visualViewport?.width ?? innerWidth);
    const vh = (window.visualViewport?.height ?? innerHeight);

    W = Math.floor(vw);
    H = Math.floor(vh);

    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);

    layout.controlH = clamp(Math.round(H * 0.26), 160, 260);

    const usableH = H - layout.controlH - layout.pad*2;
    const usableW = W - layout.pad*2;
    const s = Math.max(260, Math.min(usableW, usableH)); // ì¡°ê¸ˆ ë” í° ìµœì†Œê°’
    layout.field.s = s;
    layout.field.x = Math.floor((W - s) / 2);
    layout.field.y = layout.pad;

    updateJoystickLayout();
  }

  addEventListener("resize", resize);
  if (window.visualViewport) window.visualViewport.addEventListener("resize", resize);
  resize();

  // ---------------------------
  // 6) INPUT
  // ---------------------------
  function resetJoystick(){
    joy.active = false;
    joy.pointerId = null;
    joy.dx = 0; joy.dy = 0;
    joy.knobX = joy.baseX;
    joy.knobY = joy.baseY;
  }

  function setJoystickFromPointer(sx, sy){
    const dx = sx - joy.baseX;
    const dy = sy - joy.baseY;
    const dist = Math.hypot(dx,dy) || 1;
    const max = joy.baseR - joy.knobR;
    const t = Math.min(1, dist / max);

    const kx = joy.baseX + dx/dist * max * t;
    const ky = joy.baseY + dy/dist * max * t;

    joy.knobX = kx;
    joy.knobY = ky;
    joy.dx = (kx - joy.baseX) / max;
    joy.dy = (ky - joy.baseY) / max;
  }

  function isInJoystickArea(sx, sy){
    return sx >= joy.area.x && sx <= joy.area.x + joy.area.w
        && sy >= joy.area.y && sy <= joy.area.y + joy.area.h;
  }

  canvas.addEventListener("pointerdown", (ev) => {
    ev.preventDefault();
    const sx = ev.clientX, sy = ev.clientY;

    if (state !== STATE.PLAY) { startGame(); return; }

    if (isInJoystickArea(sx, sy) && !joy.active) {
      joy.active = true;
      joy.pointerId = ev.pointerId;
      canvas.setPointerCapture(ev.pointerId);
      setJoystickFromPointer(sx, sy);
    }
  }, { passive:false });

  canvas.addEventListener("pointermove", (ev) => {
    if (state !== STATE.PLAY) return;
    if (!joy.active || ev.pointerId !== joy.pointerId) return;
    ev.preventDefault();
    setJoystickFromPointer(ev.clientX, ev.clientY);
  }, { passive:false });

  canvas.addEventListener("pointerup", (ev) => { if (ev.pointerId === joy.pointerId) resetJoystick(); });
  canvas.addEventListener("pointercancel", (ev) => { if (ev.pointerId === joy.pointerId) resetJoystick(); });

  // ---------------------------
  // 7) SPAWN / GAME
  // ---------------------------
  function spawnBullet() {
    if (bullets.length >= maxBullets) return;

    const S = layout.field.s;
    const pair = choice(PAIRS);

    const wantHiraBullets = isPlayerHangul();
    const text = wantHiraBullets ? pair.hira : pair.hangul;

    const edge = randInt(4);
    const pad = 12;
    let x, y;
    if (edge === 0) { x = Math.random()*S; y = -pad; }
    else if (edge === 1) { x = S+pad; y = Math.random()*S; }
    else if (edge === 2) { x = Math.random()*S; y = S+pad; }
    else { x = -pad; y = Math.random()*S; }

    const dx = (player.x - x);
    const dy = (player.y - y);
    const dist = Math.max(0.001, Math.hypot(dx,dy));
    const dirx = dx/dist, diry = dy/dist;

    // âœ… ì†ë„ëŠ” speedTime ê¸°ì¤€(í”¼ê²© í›„ ë¦¬ì…‹ ê°€ëŠ¥)
    // (ì´ì „ ìš”ì²­ ìœ ì§€) ì‹œì‘ 1/2, ì¦ê°€ 1/3
    const base = 60 + Math.min(260, speedTime * 2);
    const jitter = (Math.random()*26 - 13);
    const speed = base + jitter;

    const r = clamp(Math.round(S*0.03), 12, 18);
    bullets.push({ x, y, vx: dirx*speed, vy: diry*speed, text, pair, r });
  }

  function startGame(){
    state = STATE.PLAY;
    bullets.length = 0;
    mistakes.clear();

    lives = 3;
    score = 0;
    timeAlive = 0;
    speedTime = 0;

    spawnAcc = 0;
    spawnRate = 1.6;
    maxBullets = 180;

    auraT = 0;
    player.invincible = false;

    const S = layout.field.s;
    player.x = S*0.5;
    player.y = S*0.65;
    setRandomPlayerChar(null);

    resetJoystick();
  }

  // ---------------------------
  // 8) RENDER
  // ---------------------------
  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawTextWithStroke(text, x, y, fontPx, fill, stroke, strokeW=2) {
    ctx.font = `800 ${fontPx}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", "Apple SD Gothic Neo", sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineWidth = strokeW;
    ctx.strokeStyle = stroke;
    ctx.fillStyle = fill;
    ctx.strokeText(text, x, y);
    ctx.fillText(text, x, y);
  }

  function renderFieldFrame(){
    ctx.strokeStyle = "rgba(233,238,248,0.10)";
    ctx.lineWidth = 1;
    roundRect(ctx, layout.field.x, layout.field.y, layout.field.s, layout.field.s, sp(16));
    ctx.stroke();
  }

  function renderHUD(){
    const pad = sp(12);
    const correct = currentCorrectText();

    ctx.save();
    ctx.beginPath();
    ctx.rect(layout.field.x, layout.field.y, layout.field.s, layout.field.s);
    ctx.clip();

    // âœ… HUD ê¸€ìë„ ë” í¼
    ctx.fillStyle = "rgba(233,238,248,0.92)";
    ctx.font = `700 ${clamp(sp(14), 13, 18)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    ctx.fillText(`ì ìˆ˜: ${Math.floor(score)}`, layout.field.x + pad, layout.field.y + pad);
    ctx.fillText(`ëª©ìˆ¨: ${"â—".repeat(lives)}${"â—‹".repeat(Math.max(0,3-lives))}`, layout.field.x + pad, layout.field.y + pad + sp(18));
    ctx.fillText(`ë¨¹ì–´ì•¼ í•˜ëŠ” ê¸€ì: ${correct}`, layout.field.x + pad, layout.field.y + pad + sp(36));

    ctx.restore();
  }

  function renderJoystick(){
    const yTop = joy.area.y;
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(0, yTop, W, joy.area.h);

    ctx.beginPath();
    ctx.arc(joy.baseX, joy.baseY, joy.baseR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(233,238,248,0.06)";
    ctx.fill();
    ctx.strokeStyle = "rgba(233,238,248,0.14)";
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(joy.knobX, joy.knobY, joy.knobR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(233,238,248,0.18)";
    ctx.fill();
    ctx.strokeStyle = "rgba(233,238,248,0.24)";
    ctx.stroke();

    if (W >= 360) {
      ctx.fillStyle = COLOR_TEXT_DIM;
      ctx.font = `600 ${clamp(sp(13), 12, 18)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("í•˜ë‹¨ ì¡°ì´ìŠ¤í‹±ìœ¼ë¡œ ì´ë™", W/2, yTop + sp(10));
    }
  }

  function renderStart(){
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "rgba(255,255,255,0.01)";
    ctx.fillRect(layout.field.x, layout.field.y, layout.field.s, layout.field.s);
    renderFieldFrame();

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "rgba(233,238,248,0.95)";
    ctx.font = `900 ${clamp(sp(30), 26, 40)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("íˆë¼ê°€ë‚˜ íŠ¹í›ˆ", W/2, layout.field.y + layout.field.s*0.30);

    ctx.font = `650 ${clamp(sp(15), 14, 20)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillStyle = COLOR_TEXT_DIM;
    const lines = [
      "ì› ì•ˆ ê¸€ìì™€ ì§ì´ ë˜ëŠ” ê¸€ìë§Œ ë¨¹ê¸°",
      "í‹€ë¦¬ë©´ ëª©ìˆ¨ -1 (ë¬´ì  + ì§ ë²ˆê°ˆì•„ í‘œì‹œ)",
      "í”¼ê²© ì‹œ íƒ„ë§‰ì´ ì‚¬ë¼ì¡Œë‹¤ê°€ ë‹¤ì‹œ ì§„ì…",
    ];
    let y = layout.field.y + layout.field.s*0.44;
    for (const s of lines){ ctx.fillText(s, W/2, y); y += sp(20); }

    const bw = clamp(sp(170), 150, 220);
    const bh = clamp(sp(50), 44, 60);
    const bx = W/2 - bw/2;
    const by = layout.field.y + layout.field.s*0.64 - bh/2;

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.strokeStyle = "rgba(233,238,248,0.18)";
    ctx.lineWidth = 1;
    roundRect(ctx, bx, by, bw, bh, sp(16));
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "rgba(233,238,248,0.92)";
    ctx.font = `900 ${clamp(sp(20), 18, 26)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("ì‹œì‘", W/2, layout.field.y + layout.field.s*0.64);

    renderJoystick();
  }

  function renderOver(){
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "rgba(255,255,255,0.01)";
    ctx.fillRect(layout.field.x, layout.field.y, layout.field.s, layout.field.s);
    renderFieldFrame();

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "rgba(233,238,248,0.95)";
    ctx.font = `900 ${clamp(sp(30), 26, 40)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("ê²Œì„ ì˜¤ë²„", W/2, layout.field.y + layout.field.s*0.20);

    ctx.font = `700 ${clamp(sp(16), 14, 22)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillStyle = COLOR_TEXT_DIM;
    ctx.fillText(`ìµœì¢… ì ìˆ˜: ${Math.floor(score)}`, W/2, layout.field.y + layout.field.s*0.29);

    // í‹€ë¦° ëª©ë¡ (ìƒìœ„ 10ê°œ)
    const arr = Array.from(mistakes.values()).sort((a,b)=>b.count-a.count).slice(0, 10);

    const boxW = Math.min(layout.field.s - sp(18), sp(560));
    const boxX = W/2 - boxW/2;
    const boxY = layout.field.y + layout.field.s*0.36;
    const rowH = clamp(sp(24), 22, 32);
    const boxH = sp(44) + Math.max(1, arr.length) * rowH + sp(44);

    ctx.fillStyle = "rgba(255,255,255,0.04)";
    ctx.strokeStyle = "rgba(233,238,248,0.14)";
    ctx.lineWidth = 1;
    roundRect(ctx, boxX, boxY, boxW, boxH, sp(16));
    ctx.fill(); ctx.stroke();

    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillStyle = "rgba(233,238,248,0.92)";
    ctx.font = `800 ${clamp(sp(14), 13, 20)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("í‹€ë¦° ëª©ë¡ / ì •ë‹µ (ë¡œë§ˆì í¬í•¨)", boxX + sp(14), boxY + sp(12));

    ctx.font = `650 ${clamp(sp(13), 12, 18)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillStyle = COLOR_TEXT_DIM;

    if (arr.length === 0) {
      ctx.fillText("í‹€ë¦° í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤! ğŸ‰", boxX + sp(14), boxY + sp(38));
    } else {
      let y = boxY + sp(38);
      for (const it of arr) {
        const p = it.pair;
        ctx.fillText(`â€¢ ${p.hira} â†” ${p.hangul} (${p.romaji}) Ã—${it.count}`, boxX + sp(14), y);
        y += rowH;
      }
    }

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(233,238,248,0.9)";
    ctx.font = `800 ${clamp(sp(16), 14, 22)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.fillText("íƒ­í•´ì„œ ì¬ë„ì „", W/2, boxY + boxH - sp(20));

    renderJoystick();
  }

  function renderPlay(){
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "rgba(255,255,255,0.01)";
    ctx.fillRect(layout.field.x, layout.field.y, layout.field.s, layout.field.s);
    renderFieldFrame();

    ctx.save();
    ctx.beginPath();
    ctx.rect(layout.field.x, layout.field.y, layout.field.s, layout.field.s);
    ctx.clip();

    // aura
    if (auraT > 0) {
      const t = auraT / auraDuration;
      const ps = toScreen(player.x, player.y);
      ctx.beginPath();
      ctx.arc(ps.x, ps.y, auraRadius * (1 - t*0.15), 0, Math.PI*2);
      ctx.strokeStyle = `rgba(233,238,248,${0.08 + 0.12*t})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // âœ… íƒ„ë§‰ ê¸€ì ë” í¬ê²Œ (ëª¨ë°”ì¼ ê°€ë…ì„± ê°•í™”)
    const bulletFont = clamp(sp(26), 22, 40);
    for (const b of bullets) {
      const s = toScreen(b.x, b.y);
      drawTextWithStroke(b.text, s.x, s.y, bulletFont, COLOR_TEXT, COLOR_STROKE, 2);
    }

    // player
    const ps = toScreen(player.x, player.y);
    const alpha = player.invincible ? (player.blinkShowAlt ? 0.35 : 1.0) : 1.0;

    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.fillStyle = COLOR_PLAYER_FILL;
    ctx.arc(ps.x, ps.y, player.r, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    let pChar = player.char;
    if (player.invincible) pChar = player.blinkShowAlt ? player.blinkB : player.blinkA;

    // âœ… í”Œë ˆì´ì–´ ê¸€ìë„ ë” í¬ê²Œ
    ctx.font = `900 ${clamp(Math.round(player.r*1.05), 18, 32)}px system-ui, -apple-system, "Noto Sans KR", "Noto Sans JP", sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = COLOR_PLAYER_TEXT;
    ctx.fillText(pChar, ps.x, ps.y);

    if (player.invincible) {
      const pulse = 1 + 0.08 * Math.sin(performance.now() * 0.02);
      ctx.beginPath();
      ctx.arc(ps.x, ps.y, player.r * 1.25 * pulse, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(233,238,248,0.32)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.restore();

    renderHUD();
    renderJoystick();
  }

  function render(){
    if (state === STATE.START) renderStart();
    else if (state === STATE.PLAY) renderPlay();
    else renderOver();
  }

  // ---------------------------
  // 9) UPDATE LOOP
  // ---------------------------
  let lastT = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - lastT) / 1000);
    lastT = now;

    if (state === STATE.PLAY) {
      timeAlive += dt;

      // âœ… ìŠ¤í”¼ë“œ íƒ€ì´ë¨¸ëŠ” "íƒ„ë§‰ì´ ì‹¤ì œë¡œ ë“¤ì–´ì˜¤ê¸° ì‹œì‘í•œ ë’¤"ì—ë§Œ ì¦ê°€ì‹œí‚¤ê³  ì‹¶ìŒ
      // ìš”êµ¬: "4íšŒ ê¹œë¹¡ì¸ ì´í›„ë¶€í„° íƒ„ë§‰ì´ ì§„ì…"
      const allowSpawn = !(player.invincible && player.blinkCount < 4);

      if (allowSpawn) speedTime += dt;

      // ë‚œì´ë„: ìŠ¤í°/ìµœëŒ€íƒ„ë§‰ (ê¸°ì¡´ ìœ ì§€)
      spawnRate = Math.min(10.0, 1.6 + timeAlive * 0.08);
      maxBullets = Math.min(420, 180 + Math.floor(timeAlive * 3.0));

      // âœ… ê¹œë¹¡ì„ 4íšŒ ì „ì—ëŠ” íƒ„ë§‰ ìƒì„± ì™„ì „ ì¤‘ì§€ + í™”ë©´ë„ ë¹„ìš°ê¸°
      if (!allowSpawn) {
        if (bullets.length) bullets.length = 0;
        spawnAcc = 0;
      } else {
        spawnAcc += dt * spawnRate;
        while (spawnAcc >= 1) { spawnAcc -= 1; spawnBullet(); }
      }

      // ì´ë™
      const S = layout.field.s;
      const len = Math.hypot(joy.dx, joy.dy);
      const mag = clamp(len, 0, 1);
      player.x += joy.dx * player.speed * mag * dt;
      player.y += joy.dy * player.speed * mag * dt;
      player.x = clamp(player.x, player.r, S - player.r);
      player.y = clamp(player.y, player.r, S - player.r);

      // ë¬´ì  ê¹œë¹¡ì„ ì—…ë°ì´íŠ¸
      if (player.invincible) {
        player.blinkT += dt;
        const toggles = Math.floor(player.blinkT / player.blinkInterval);
        if (toggles > player.blinkCount) {
          player.blinkCount = toggles;
          player.blinkShowAlt = !player.blinkShowAlt;
        }
        if (player.blinkT >= player.blinkTotal) {
          player.invincible = false;
          setRandomPlayerChar(player.char);
        }
      }

      if (auraT > 0) auraT = Math.max(0, auraT - dt);

      // ì¶©ëŒ
      const correctText = currentCorrectText();
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        if (b.x < -80 || b.x > S+80 || b.y < -80 || b.y > S+80) {
          bullets.splice(i,1);
          continue;
        }

        const d = Math.hypot(b.x - player.x, b.y - player.y);
        if (d <= b.r + player.r) {
          const isCorrect = (b.text === correctText);
          bullets.splice(i,1);

          if (isCorrect) {
             onEatCorrect(b.pair);
          } else if (!player.invincible) {
             onHitWrong(b.pair);
             break; // â˜…ì¤‘ìš”: onHitWrongì—ì„œ bulletsë¥¼ ë¹„ìš°ë¯€ë¡œ ë£¨í”„ ì¢…ë£Œ
          }
        }
      }

      score += dt * 8;
    }

    render();
    requestAnimationFrame(tick);
  }

  resetJoystick();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
